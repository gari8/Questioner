// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"

	"github.com/99designs/gqlgen/graphql"
)

type Node interface {
	IsNode()
}

type Answer struct {
	ID        int       `json:"id"`
	User      *User     `json:"user"`
	Question  *Question `json:"question"`
	Content   *string   `json:"content"`
	CreatedAt *string   `json:"created_at"`
	UpdatedAt *string   `json:"updated_at"`
}

type Choice struct {
	ID       int       `json:"id"`
	Content  string    `json:"content"`
	Value    int       `json:"value"`
	Question *Question `json:"question"`
}

type ChoiceInput struct {
	Content string `json:"content"`
}

type EditQuestion struct {
	Title      string     `json:"title"`
	Content    string     `json:"content"`
	AnswerType AnswerType `json:"answerType"`
	TermStart  string     `json:"termStart"`
	TermEnd    string     `json:"termEnd"`
	Published  bool       `json:"published"`
	Enabled    bool       `json:"enabled"`
}

type EditUser struct {
	ID          string         `json:"id"`
	Username    string         `json:"username"`
	Email       string         `json:"email"`
	Icon        graphql.Upload `json:"icon"`
	Description string         `json:"description"`
}

type LoginInput struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type NewAnswer struct {
	UserID string          `json:"userId"`
	Value  *string         `json:"value"`
	File   *graphql.Upload `json:"file"`
}

type NewQuestion struct {
	UserID            string         `json:"userId"`
	Title             string         `json:"title"`
	Content           string         `json:"content"`
	AnswerType        AnswerType     `json:"answerType"`
	TermStart         *string        `json:"termStart"`
	TermEnd           *string        `json:"termEnd"`
	Published         bool           `json:"published"`
	Enabled           bool           `json:"enabled"`
	TextAfterAnswered *string        `json:"textAfterAnswered"`
	Choices           []*ChoiceInput `json:"choices"`
}

type NewUser struct {
	Username string `json:"username"`
	Password string `json:"password"`
	Email    string `json:"email"`
}

type Question struct {
	ID                string    `json:"id"`
	Title             string    `json:"title"`
	AnswerCount       int       `json:"answerCount"`
	Answers           []*Answer `json:"answers"`
	Content           *string   `json:"content"`
	TermStart         *string   `json:"termStart"`
	TermEnd           *string   `json:"termEnd"`
	TextAfterAnswered *string   `json:"textAfterAnswered"`
	Published         bool      `json:"published"`
	Enabled           bool      `json:"enabled"`
	AnswerType        string    `json:"answerType"`
	Choices           []*Choice `json:"choices"`
	Answered          bool      `json:"answered"`
	User              *User     `json:"user"`
	Answerers         []*User   `json:"answerers"`
	CreatedAt         *string   `json:"created_at"`
	UpdatedAt         *string   `json:"updated_at"`
}

func (Question) IsNode() {}

type User struct {
	ID            string      `json:"id"`
	Username      string      `json:"username"`
	Icon          *string     `json:"icon"`
	Email         *string     `json:"email"`
	Password      *string     `json:"password"`
	Description   *string     `json:"description"`
	QuestionCount *int        `json:"questionCount"`
	AnswerCount   *int        `json:"answerCount"`
	Answers       []*Answer   `json:"answers"`
	Questions     []*Question `json:"questions"`
	CreatedAt     *string     `json:"created_at"`
	UpdatedAt     *string     `json:"updated_at"`
}

func (User) IsNode() {}

type AnswerType string

const (
	AnswerTypeFree   AnswerType = "free"
	AnswerTypeSelect AnswerType = "select"
	AnswerTypeWord   AnswerType = "word"
	AnswerTypePhoto  AnswerType = "photo"
)

var AllAnswerType = []AnswerType{
	AnswerTypeFree,
	AnswerTypeSelect,
	AnswerTypeWord,
	AnswerTypePhoto,
}

func (e AnswerType) IsValid() bool {
	switch e {
	case AnswerTypeFree, AnswerTypeSelect, AnswerTypeWord, AnswerTypePhoto:
		return true
	}
	return false
}

func (e AnswerType) String() string {
	return string(e)
}

func (e *AnswerType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AnswerType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AnswerType", str)
	}
	return nil
}

func (e AnswerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
